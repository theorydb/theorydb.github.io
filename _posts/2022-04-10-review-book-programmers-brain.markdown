---  
layout: post  
title: "[리뷰] 프로그래머의 뇌"  
subtitle: "훌륭한 프로그래머가 알아야 할 인지과학의 모든 것"  
categories: review  
tags: review book 프로그래머 인지과학 습관 코드 혼란 해결 문법 가독성 개념적기계 표기법 버그 명명 프레임워크 협업 설계 적응   
comments: true  
header-img: img/review/review-book-programmers-brain-1.png
---  
  
> `제이펍` 출판사의 `"프로그래머의 뇌(펠리너 헤르만스 저/차건회 역)"`를 읽고 작성한 리뷰입니다.  

![표지](https://theorydb.github.io/assets/img/review/review-book-programmers-brain-1.png)  

---

> 우리 뇌에서 일어나는 인지 과정을 이해하여 효율적인 프로그래밍을 가능하게 해주는 프로그래머들의 필독서이다.

프로그래밍을 배운다는 것은 쉬운 일이 아니다. 이미 완숙한 경지에 오른 고수 프로그래머들도 분명 처음 프로그래밍을 접할 때 힘든 과정을 거쳤을 것이고 이제 막 프로그래밍 세계에 입문한 초보자는 현 시점이 그 어려운 순간일 것이다. 

개인적으로 스스로를 고수라 평하기엔 객관적으로 입증할 방법이 없고 부끄러운 부분인지라 머뭇거리게 되지만 1만 시간의 법칙이 맞다는 가정하에 스스로 왠만한 프로그램을 배우는 데 큰 어려움이 없다는 것은 동의할 수 있는 부분이다. 

그동안 프로그래밍에 어려움이 있었다면 그저 1차원 적으로 노력과 연습, 반복만이 답이라고 여겨왔는데 이 책을 읽고 프로그래밍에 숙달하기까지의 과정에는 `여러 길`이 있으며 특히 우리 두뇌의 특성을 파악하고 상황에 맞는 효율적인 방법을 선택하는 것이 얼마나 중요한 일인지 인지하게 되었다. 

특히 파트1의 내용은 1만 시간이 넘는 프로그래밍 시간동안 느꼈던 부분들을 아주 잘 정리하고 있으며 뒤에 이어질 파트들의 근간을 이루는 지식들이 담겨 있기에 리뷰에서는 파트1을 중점적으로 소개해볼까 한다. 파트 1이 마음에 든다면 파트 2 이후에 이어지는 내용도 매우 만족스러울 것이라 기대해도 좋다. 

파트1의 시작은 `3가지 프로그램`을 읽고 해석하는데에서 출발한다. 클린코드와 같은 또 다른 명서들이 코드 쓰기에 초점을 맞추고 있다면 이 책은 코드 읽기에 보다 초점을 맞춘다. 

물론 가독성을 확보한 코드들이 장기적인 기억 즉, LTM의 효율성을 높혀 주기에 쓰기도 매우 중요한 부분임을 강조하지만 읽기 자체가 두뇌의 인지과정과 보다 밀접하게 닿아있고 지금까지의 교육이 읽기보다는 쓰기에 초점이 맞춰줘 있었다는데 착안하여 저자는 읽기 과정에서의 인지 결합을 더 중점적으로 다루고 있다. 

아래 그림에 등장하는 세가지 언어로 작성된 각각의 코드를 읽어보자. 
![코드](https://theorydb.github.io/assets/img/review/review-book-programmers-brain-2.png)  

눈치빠른 독자라면 `자바, 베이직, APL`로 작성된 각각의 예제를 보며 두뇌를 쓰는 방식에 미묘한 차이를 느꼈을 것이다. 

다만 이미 프로그래밍이 익숙한 나의 경우에는 각 코드별로 저자가 의도하는 바를 쉽게 눈치챌 수 있었으나 프로그래밍 경험이 전무한 사람에게는 비슷한 유형의 어려움으로 다가왔을지도 모르겠다. 

그렇기 때문에 이 책은 어느정도 프로그래밍 경험이 있는 사람이 읽을수록 더 얻는 것이 많으리라는 생각이 들었다. 물론 아예 프로그래밍 경험이 전무한 사람에게도 큰 도움이 될 것 같기에 처음 읽는 독자라면 일단 이해가 가지 않더라도 믿고 따르며 첫 발을 내딛는다면 큰 도움이 될 것 같다. 

다시 원점으로 돌아와서 자바 언어의 예제의 핵심은 `.toBinaryString()` 메소드에 달려있다. 이 메소드의 기능이 무엇인지 잘 모른다면 이 부분에서 버그가 생긴듯 사고가 정지될 것이다. 

두번째 베이직 코드의 경우 자바 예제와 같은 생소한 메소드는 등장하지 않는다. 다만 `각 단계가 복잡`하다. 각각의 변수에 어떤 값이 저장되며 변경되는지 FOR라는 루프를 돌면서 어떤 변화가 일어나는지 추적을 해야하는데 기억력이나 깊은 사고에 제약이 쌓이면 전체 그림을 이해하는데 어려움이 있을 것이다. 

세번째 APL은 좀 황당하다. 60년대에 사용되던 프로그램이라고 소개하고 있는데 아마 대부분의 독자들은 이 언어를 경험조차 하지 못했을 것이다. `T가 연산자`라고 소개하고 있는데 이게 도대체 뭐하는 연산자인지 알 길이 없다. 

요는 이 세 유형의 코드를 전부 잘 이해하는 것이 목적이 아니다. 정말 중요한 것은 각 유형별로 두뇌가 맞닥드리게 되는 어려움의 유형이 각각 다르다는 점을 인지하는 것에 있다. 

첫번째 자바 코드의 경우 메소드에 대한 정보가 없다는 것이 문제가 된다. 전혀 다른 언어인 Python을 배운다고 가정할 때도 비슷한 유형의 문제에 부딪힌다. 메소드, 라이브러리, 모듈 등의 정보가 없다면 각기 어떤 기능을 담당하며 언제 활용해야 하는지를 알 수가 없게 되므로 이에 대한 정보를 익혀야 한다. 

이 정보를 익히는 과정은 단기 기억을 활용하게 되는데 이를 `STM`이라 부른다. 컴퓨터로 따지만 RAM, Cache와 같은 영역이 우리 뇌의 STM에 해당한다고 할 수 있다. 

문제는 그간의 연구 결과에 따르면 이 STM이 많은 정보를 기억하지 못한다는데 있다. 순간 기억할 수 있는 단기 기억력이 실제로 크지 않다는 것은 우리 모두 잘 알고 있는 사실이다. 굳이 프로그래밍이 아닐지라도 간단한 그림 기억하기 퀴즈 같은 것에 도전해봐도 생각보다 단기적으로 기억할 수 있는 건수는 많지 않다는 것을 알 수 있다. 

두 번째 코드는 우리 인지과정에서 `처리능력`을 설명하기 위해 제시된 코드이다. 컴퓨터로 빗대면 CPU와 같은 프로세스에 해당된다. 작업 기억 능력이라는 인지 기능에 해당하는데 이 코드의 해석이 어렵다면 정보나 지식의 부재때문에 발생하는 것은 아니다. 

세 번째 코드는 T라는 연산자를 아예 모르는 즉, 지식의 부재에서 발생한다. 굳이 예제로 든 APL언어가 아닐지라도 프로그래밍 언어의 문법 자체나 알고리즘 등을 모르는 경우와 동일한 유형의 부하이다. 

이는 암기에 의존해야하는 부분으로 장기 기억력을 필요로 하며 이를 담당하는 기능이 `LTM`이다. 컴퓨터로 비유하자면 하드디스크에 해당되는 기능이라고 할 수 있다. 보다 많은 양을 기억할 수 있으며 제법 오랜시간 기억이 존재할 수 있는 부분이다. 

그동안 프로그래밍의 이해에 어려움이 있다면 막연히 모두 같은 유형으로 싸잡아 묶어오다가 두뇌의 인지과정과 빗대어 부하를 일으키는 유형을 잘 정리하고 있는 책이라는 생각이 들었다. 

프로그래밍 세계와 인지 과학의 세계 두마리 토끼를 모두 이해하고 있는 고수가 아닌 이상 우리의 사고과정을 이렇게 명쾌하게 정리하기에 어려움이 있을텐데 이 두 주제를 제대로 이해해보고 앞으로의 프로그래밍 역량을 향상시킬 수 있다는 점이 이 책이 가진 가장 큰 장점이라 할 수 있겠다. 

이어지는 주제로 삽입 정렬과 같은 코드를 3분 정도 유심히 들여다 본 후 책을 덮고 기억력에만 의존하여 그대로 `필사`해 보는 훈련을 여러번 진행하게 된다. 그 과정을 통해 정말로 우리 두뇌가 위에서 저자가 말한 세가지 유형의 방식으로 움직이고 있다는 사실을 확인할 수 있다. 

내가 생각하는 과정을 들여다 볼 수 있다는 것은 정말 놀라운 경험이었다. 또 더불어 저자가 분류한 인지 과정에 신뢰감을 갖기에 충분한 과정이었고 이를 통해 내가 앞으로 겪어야 할 문제의 유형에 맞춤형 진단과 해법을 내릴 수 있다는 점에서 이 책은 반드시 한 번 즈음 읽어봐야 할 필독서라는 생각이 들었다. 

이 과정을 거친 후 프로그래밍에서 맞닥드리게 될 문제를 돌파하는데 가장 중요한 아이디어 중의 하나가 STM과 LTM의 효율적인 활용이라는 생각이 들었다. 

평소 꾸준한 노력과 반복, 연습을 통해 LTM에 충분한 정보와 기초를 잘 다진 후 STM의 능력을 극대화하기 위해 청크의 용량을 늘릴 필요가 있다는 생각이 들었다. 

이는 체스 실험을 통해서 잘 소개되고 있는데 체스판 위에 말들을 아무렇게 배치해놓고 체스 전문가와 일반인의 기억력을 실험한 일화이다. 

흥미로운 사실은 실제 체스 경기중에 일어날 수 있는 경우의 말 배치는 전문가가 월등히 잘 기억한 반면에 체스 규칙과 무관한 말의 배열은 전문가나 일반인이 기억력에 큰 차이가 없다는 점이었다. 

이렇게 즉석에서 무언가를 기억해 내는 능력은 STM에 의존하게 되는데 STM은 사람마다 약간의 차이는 있어도 대략 6개 정도의 공간만 동시에 활용할 수 있다는 점이 문제이다. 

다만 `비슷한 주제는 청크로 묶여 하나로 인식`되기에 LTM을 기반으로 한 청크를 최대한 활용하면 순간적으로도 엄청난 기억력을 자랑할 수 있게 되는 셈이다.

예를 들면 아래 그림이 좋은 예제가 되겠다. 
![청크](https://theorydb.github.io/assets/img/review/review-book-programmers-brain-5.png)  

첫번째 문자는 전혀 생소한 문자와 문장이다. 단 5초만 주어진다면 이 예제를 완벽히 기억해내는데 대부분 한계에 부딪힌다. 

반면 두번째 유형의 문제는 적어도 문자는 우리에게 익숙한 알파벳이다. 다만 문장은 생소하다. 첫번째 유형보다는 보다 빠르게 많은 양을 기억해 낼 수 있겠지만 어렵기는 여전하다. 

마지막 세번째 유형은 1초면 암기할 수 있다. 문자도 익숙한 알파벳이며 문장도 익숙하게 바로 해석이 되는 문장이다.

이제 `청크의 개념`이 무엇인지 이해가 되시는지?

이 책에서 다루는 심오한 인지과학의 세계는 이것으로 끝이 아니다. 본 리뷰에서 다룬 것은 극히 일부분일 뿐이다. 클린 코드와 같은 유명한 도서들이 다루는 내용에 인지과학의 세계를 포함시킨 책이라고 보면 딱 맞는 설명이 될 수 있을 것 같다.

이 LTM, STM, Working Memory의 세 인지 과정을 잘 이해한 후 이어지는 파트들을 읽는 다면 그간의 프로그래밍 세계에서 겪었던 경험들이 슬기롭게 조화되고 통합되는 신기한 경험을 마주할 수 있을 것이다. 

프로그래밍에 어려움을 겪을 때 활용할 만한 작업 기억 공간을 돕는 앱이나 의존 그래프 및 상태표를 활용하는 아이디어는 물론 대규모 프로젝트를 성공적으로 마무리 짓기 위한 방법론이나 협업에서 활용할 수 있는 방안들도 자세하게 소개되어 있다. 
![작업기억공간](https://theorydb.github.io/assets/img/review/review-book-programmers-brain-3.png)  
![의존그래프](https://theorydb.github.io/assets/img/review/review-book-programmers-brain-4.png)  

나를 알고 적을 알면 백전백승인 법. 우리 자신의 메타 인지과정을 느끼고 이해하며 프로그래밍의 세계를 항해한다면 보다 빠른 시간 내에 원하는 것을 쟁취할 수 있을 것이라 생각되기에 프로그래밍 세계에 발을 담근 모든 이에게 추천하고 싶은 도서이다. 

더불어 프로그래밍이라는 소양이 기본 교육 과정에 포함되는 요즈음 문제 해결 능력을 키우고 싶은 모든 학생들에게도 권장하는 바이다.

---

* [책소개 - 프로그래머의 뇌](http://www.yes24.com/Product/Goods/105911017)


